<h2>Editing levels with Yadex</h2>

<h3>Using external textures, flats, etc.</h3>

<p>Like Doom, Yadex accepts the addition and replacement of
resources from a pwad. In general, if the same resource is
defined in several wads, the last definition is used. This is
also true if the same resource is defined several times in the
same wad. It's not recommended that you use lower case names in
your wads; sometimes it's handled but sometimes it's not. So
always use upper-case names.</p>

<dl>
  <dt>Flats
  <dd>New or replacement flats are recognized iff they're placed
    between <code>FF_START</code>/<code>F_END</code> or
    <code>FF_START</code>/<code>FF_END</code> labels. There can
    be any number of <code>FF_START</code>/<code>F_END</code>
    and <code>FF_START</code>/<code>FF_END</code> pairs and they
    don't have to be in the same pwad. If there are several
    lumps for the same flat, the last one is used.

  <dt>Palette
  <dd>If there is a replacement <code>PLAYPAL</code> lump, it's
    used. If there are several <code>PLAYPAL</code> lumps, the
    last one is used.

  <dt>Patches
  <dd>New or replacement patches are recognized iff they're
    between <code>P_START</code> and <code>P_END</code> or
    <code>PP_START</code> and <code>PP_END</code>. Within a
    group of patches, labels <code>P1_START</code>,
    <code>P1_END</code>, <code>P2_START</code>,
    <code>P2_END</code>, <code>P3_START</code> and
    <code>P3_END</code> are ignored&nbsp;; any other label
    elicits a warning. New patches must also appear in the
    <code>PNAMES</code> lump or the texture browser won't be
    able to use them. If there are several <code>PNAMES</code>
    lumps, the last one is used. If there are several lumps for
    the same flat, the last one is used.

  <dt>Sprites
  <dd>New or replacement sprites are recognized iff they're
    between one of the following pair of labels&nbsp;:
    <code>S_START</code>/<code>S_END</code>,
    <code>SS_START</code>/<code>S_END</code> or
    <code>SS_START</code>/<code>SS_END</code>. There can be any
    number of label pairs and they don't have to be in the same
    pwad. If there are several lumps for the same sprite, the
    last one is used.

  <dt>Textures
  <dd>New or replacement textures are recognized iff they're in
    a <code>TEXTURE1</code> or <code>TEXTURE2</code> lump. If
    the same texture happens to be defined in both
    <code>TEXTURE1</code> and <code>TEXTURE2</code> (which
    should not happen), only the definition in
    <code>TEXTURE1</code> is used. If there are several
    <code>TEXTURE1</code> lumps, the last one is used. If there
    are several <code>TEXTURE2</code> lumps, the last one is
    used. If it exists, <code>TEXTURE2</code> is always
    susceptible to be used, even for games where it's not
    supposed to exist, like Doom&nbsp;II.
</dl>

		<h3>Logging of time spent</h3>

<p>If you edit a level from a file and there exists a file in
the same directory with the same name but with the extension
<code>.yl</code>, that file will be used to keep track of the
time you spent editing that level. At the end of the editing
session, Yadex will append a line to the <code>.yl</code> file
with the name of the level and the number of minutes spent on
it.

<p> Note that if the <code>.yl</code> file does not already
exist, it is <em>not</em> created. This is to prevent the
creation of a large number of small useless files when browsing
through a collection of wads. Thus, if you want to enable
logging, you need to manually create the log file first with a
command such as "<code>touch <var>name</var>.yl</code>".

		<h3>The prompt commands</h3>

<p>You can get a summary of the prompt commands
by typing "<code>?</code>" at the Yadex prompt.

		<h3>Moving around</h3>

			<h4>Moving the pointer</h4>

<p>In the X11 version, the only way to do that is to
move the pointer device (i.e. the mouse).

			<h4>Scrolling</h4>

<p>The arrow keys [<kbd>left</kbd>], [<kbd>right</kbd>],
[<kbd>up</kbd>] and [<kbd>down</kbd>] scroll a little at a time,
by default 10% of the screen/window width or height. You can
change the exact amount by setting the variable
<code>scroll_less</code> in the configuration file.

<p>[<kbd>pgup</kbd>], [<kbd>pgdn</kbd>], [<kbd>home</kbd>] and
[<kbd>end</kbd>] scroll more at a time, by default 90% of the
screen/window width or height. You can change the exact amount
by setting the variable <code>scroll_more</code> in the
configuration file.

			<h4>Autoscrolling</h4>

<p>By default, autoscrolling is disabled. You can enable it by
setting <code>autoscroll</code> to <code>true</code> in the
configuration file.

<p>When it is enabled and the pointer is close to the edge of
the screen/window, the map scrolls automatically. The closer you
are to the edge, the faster it scrolls. Autoscrolling is always
disabled near the menu bar items so that the map does not scroll
when you're reaching for the menu.

<p>You can fine tune autoscrolling by changing the variables
<code>autoscroll_amp</code> and <code>autoscroll_edge</code>.

			<h4>Jumping</h4>

<p>I plan to develop a full set-mark/jump-to-mark system similar
to the one in <code>vi</code>, with
<code>m<var>mark-name</var></code>,
<code>'<var>mark-name</var></code> and
<code>`<var>mark-name</var></code>.

<p>For the moment, if you press [<kbd>'</kbd>], the map scrolls
so that its centre is at the centre of the screen/window.

<p>If you press [<kbd>`</kbd>], the map scrolls so that its
centre is at the centre of the screen/window and the zoom factor
is adjusted so that the whole map is visible and almost fills
the screen/window.

		<h3>Zooming in and out</h3>

<p>The current zoom factor is shown on the info bar, after the
word "<code>Scale:</code>". It is shown in pixels per map
units. The indication "<code>Scale: 50%</code>" means that one
pixel of the display corresponds to 2 map units.

<p>You can zoom in by pressing [<kbd>+</kbd>] or [<kbd>=</kbd>]
or the 4th mouse button or by moving the mouse wheel "up". See
the <code>zoom_default</code> and <code>zoom_step</code>
variables.

<p> You can zoom out by pressing [<kbd>-</kbd>] or
[<kbd>_</kbd>] or the 5th mouse button or by moving the mouse
wheel "down". See the <code>zoom_default</code> and
<code>zoom_step</code> variables.

<p> You can also set the zoom factor directly with the keys
[<kbd>1</kbd>] through [<kbd>9</kbd>] and [<kbd>0</kbd>].
[<kbd>1</kbd>] sets the zoom factor to a value that is
controlled by the <code>digit_zoom_base</code> variable (by
default, 100%). Each successive key down the keyboard sets the
zoom factor <code>digit_zoom_step</code> percents higher than
the previous one (by default, -29%).

		<h3>The grid</h3>

<p>The <dfn>grid</dfn> is a square mesh of blue dots and lines
in the background. It's here to help you aligning your objects
correctly with regard to Doom's metrics, which will save you a
lot of textures misalignments.

<p> When you insert or drag objects, they are <dfn><i>snapped to
grid</i></dfn>. That is, Yadex prevents you from placing them
off the grid. You can toggle the <code>snap_to_grid</code> flag
by pressing [<kbd>y</kbd>].

<p> The grid step is always a power of 2, E.G. 128, 64, 32, etc.
You can get a finer grid (dividing the grid step by 2) by
pressing [<kbd>g</kbd>]. Conversely, pressing [<kbd>G</kbd>]
multiplies the grid step by 2. If you press [<kbd>g</kbd>] when
the grid step is already at its minimum value, it will be set to
its maximum value. And conversely. The minimum and maximum
values are set in the configuration file with
<code>grid_min</code> and <code>grid_max</code>.

<p> When you change the zoom factor, Yadex automatically changes
the grid step to make it what it thinks is best for the new zoom
factor. If you want to lock the grid step to its current value,
press [<kbd>z</kbd>]. To unlock it, press that key again.

<p> You can hide the grid by pressing [<kbd>h</kbd>] (but this
doesn't disable <code>snap_to_grid</code>). Press that key
again to make the grid visible again.

<p>You can also use [<kbd>H</kbd>] to reset the grid step.

		<h3>Highlighting objects</h3>

    <p>
      At any given time, zero or one object can be "highlighted".
      The highlighted object is the "current" object; it's the one on which
      operations are performed if the selection is empty.
      It's also the one whose attributes are shown in the object info box.
    </p>

    <p>
      The highlighted object is indicated by a yellow outline.
    </p>

    <p>
      There are several ways to control which object is highlighted but the
      primary one is to move the pointer. 
      Moving the pointer over an object (or sufficiently close to it)
      highlights it.
      Moving the pointer away from an object unhiglights it.
      If there are several objects in the vicinity of the pointer, the one to
      highlight is determined according to the following rules&nbsp;:
    </p>

    <ul>
      <li>
	For vertices, it's the vertex that's closest to the pointer.
	If several vertices are equally close, it's the highest-numbered one
	that's highlighted.
      </li>

      <li>
	For linedefs, it's the linedef that's closest to the pointer.
	If several linedefs seem equally close, which usually happens when
	there are superimposed linedefs, it's the highest-numbered one that's
	highlighted.
      </li>

      <li>
	For things, the highlighted object is the one inside of which the
	pointer is.
	If this is not sufficient to arbitrate, the highlighted object is the
	which has the smallest radius.
	If this is still not sufficient to arbitrate, the object that's closest
	to the pointer wins.
	As a last resort, the highest-numbered object wins.
      </li>

      <li>
	In global mode, all these criteria are somehow combined.
      </li>
    </ul>

    <p>
      Keeping the [<kbd>shift</kbd>] key pressed prevents the highlight from
      changing.
      If no object is highlighted, bringing the pointer over an object does not
      highlight it.
      If an object is already higlighted, moving the pointer away or over
      another object does not unhiglight it.
      This can be useful in certain occasions, such as when you want to compare
      two sectors that have other sectors between them.
    </p>

		<h3>The object info box</h3>

    <p>
      The object info box is displayed in the bottom corner of the editing
      window and shows the attributes of the highlighted object.
      Here are the non-obvious parts of it.
    </p>

    <dl>
      <dt>Linedef tag
      <dd>
	The parenthesised part of the field is the number of the sectors that
	are tagged to the linedef (i.e. have the same tag).
	If there are more than one tagged sectors, the number of the
	lowest-numbered one is shown, followed by a plus sign
	("<code>+</code>").
	If there are no tagged sectors, the string "<code>(none)</code>" is
	shown.
      </dd>

      <dt>Sector tag
      <dd>Same as above (replace "linedef" by "sector" and vice-versa).

      <dt><a name="ld-type-desc">Linedef type</a>
      <dd>
        $(source ldtypes.html.m7)
      </dd>

    </dl>

		<h3>Selecting objects</h3>

There are several ways to select objects. The simplest is to
click on an object with the left mouse button. By default, when
you do that, all other previously selected objects are
unselected.

<p>If you want to select an object without unselecting
everything else, do the same thing but keep [<kbd>ctrl</kbd>]
pressed while you click. You can also unselect an object this
way.

<p>You can also select several objects at a time with a
selection box. You know how to draw a selection box, don't
you&nbsp;? Well, it works the same in Yadex. If press
[<kbd>ctrl</kbd>] while setting the first corner of the box, all
objects in the box will be "toggle-selected" (that is, selected
if they weren't, unselected if they were).

<p>A more advanced way to select objects is path-selection. With
path selection, you can easily select all the linedefs that
form an object with a single keystroke. There are two variants
of path selection.

<p>To use the first, you must first highlight a linedef. Then
press [<kbd>e</kbd>]. All the linedefs that belong to the same
non-forked path as the highlighted linedef are selected. For
example&nbsp;:</p>

<table align="center">
  <tr>
    <td><img src="e1.png" alt="Before pressing [e]" WIDTH=159 HEIGHT=127></td>
    <td><img src="e2.png" alt="After pressing [e]" WIDTH=159 HEIGHT=127></td>
  </tr>
  <tr>
    <td align="right"><i>Before pressing</i> [<kbd>e</kbd>]</td>
    <td align="right"><i>After pressing</i> [<kbd>e</kbd>]</td>
  </tr>
</table>

<p>Note how the selection stops at the first fork in the
path. That kind of path selection is good to select a path of
single- or double-sided linedefs that belong to the same sector.

<p>The other variant of path selection is better to select all
the linedefs that form a single pillar, even if not all of its
sides face the same sector. To use it, highlight a single-sided
linedef and press [<kbd>E</kbd>]. All the single-sided linedefs
that belong to the same path as the original one are
highlighted. For example&nbsp;:</p>

<table align="center">
  <tr>
    <td><img src="E1.png" alt="Before pressing [E]" WIDTH=156 HEIGHT=160></td>
    <td><img src="E2.png" alt="After pressing [E]" WIDTH=154 HEIGHT=160></td>
  </tr>
  <tr>
    <td align="right"><i>Before pressing</i> [<kbd>E</kbd>]</td>
    <td align="right"><i>After pressing</i> [<kbd>E</kbd>]</td>
  </tr>
</table>

<p>Note that the selection is not stopped by the forks in
the path.  Also note that the double-sided linedefs are not
selected.

<p>Like clicking, [<kbd>e</kbd>] and [<kbd>E</kbd>] have the
effect of unselecting everything else that was previously
selected unless you use [<kbd>ctrl</kbd>]. If [<kbd>ctrl</kbd>]
was pressed at the time you pressed [<kbd>e</kbd>] or
[<kbd>E</kbd>], all the linedefs that would have been selected
if you didn't press [<kbd>ctrl</kbd>] are either removed from
the selection (if they were previously selected) or added to the
selection (if they weren't). This is actually simpler than it
sounds.

		<h3>Inserting objects</h3>

<p>By pressing [<kbd>Ins</kbd>], you insert a new object under
the pointer.

<p>The type of the new object is generally determined by the
current mode. That is, if you are in things mode, pressing
[<kbd>Ins</kbd>] will create a new thing. However, this is not
always true, particularly if some objects are already
selected&nbsp;:

<ul>
  <li>If you are in vertices mode and there are two or more
  vertices selected, pressing [<kbd>Ins</kbd>] will insert a
  linedef from the first vertex to the second, another one from
  the second to the third and so on. That is, a path of linedefs
  is created from the first to the last vertex. The path is not
  closed (but see [<kbd>shift</kbd>][<kbd>Ins</kbd>] below).

  <li>If you are in linedefs mode and there are selected
  linedefs, pressing [<kbd>Ins</kbd>] will create a new sector
  and new sidedefs that point to it and assign them to the
  linedefs. For the linedefs that had no first sidedef (whether
  or not they already had a second sidedef), the new sidedef is
  attached as first sidedef. For the linedefs that had a first
  sidedef but no second sidedef, the new sidedef is attached as
  second sidedef.  If one or more of the selected linedefs
  already had two sidedefs, the operation fails. Bug: the side
  to which the new sidedef is attached is decided without taking
  into account the actual orientation of the linedef.
</ul>

<p>If an object of the same type is highlighted at the moment
you press [<kbd>Ins</kbd>], the properties of the new object are
copied from the highlighted object. In other words, the
highlighted object serves as a "model". Else the properties of
the new object are set to default values.</p>

<table>
  <tr valign=top>
    <th>Object type
    <th>Property
    <th>Value if there is a model
    <th>Value if there is no model

  <tr valign=top>
    <td rowspan=7>Linedef
    <td>Start vertex
    <td>Like the model
    <td>If there are two selected vertices, the first.
	    If not, you are prompted for a vertex number.

  <tr valign=top>
    <td>End vertex
    <td>Like the model
    <td>If there are two selected vertices, the second.
	    If not, you are prompted for a vertex number.

  <tr valign=top>
    <td>Flags
    <td>Like the model
    <td>Impassable

  <tr valign=top>
    <td>Type
    <td>Like the model
    <td>0 (normal)

  <tr valign=top>
    <td>Sector tag
    <td>Like the model
    <td>0 (none)

  <tr valign=top>
    <td>First sidedef
    <td>FFFFh (none)
    <td>FFFFh (none)

  <tr valign=top>
    <td>Second sidedef
    <td>FFFFh (none)
    <td>FFFFh (none)

  <tr valign=top>
    <td rowspan=4>Thing
    <td>Coordinates
    <td>Like the pointer
    <td>Like the pointer

  <tr valign=top>
    <td>Type
    <td>Like the model
    <td><a href="#param_default_thing"><code>default_thing</code></a>

  <tr valign=top>
    <td>Flags
    <td>Like the model
    <td>D12 D3 D45

  <tr valign=top>
    <td>Angle
    <td>Like the model
    <td>0 (east)

  <tr valign=top>
    <td rowspan=7>Sector
    <td>Floor height
    <td>Like the model
    <td><a href="#param_default_floor_height"><code>default_floor_height</code></a>

  <tr>
    <td>Ceiling height
    <td>Like the model
    <td><a href="#param_default_ceiling_height"><code>default_ceiling_height</code></a>

  <tr>
    <td>Floor texture
    <td>Like the model
    <td><a href="#param_default_floor_texture"><code>default_floor_texture</code></a>

  <tr>
    <td>Ceiling texture
    <td>Like the model
    <td><a href="#param_default_ceiling_texture"><code>default_ceiling_texture</code></a>

  <tr>
    <td>Light level
    <td>Like the model
    <td><a href="#param_default_light_level"><code>default_light_level</code></a>

  <tr>
    <td>Type
    <td>Like the model
    <td>0 (normal)

  <tr>
    <td>Tag
    <td>Like the model
    <td>0 (none)

  <tr valign=top>
    <td>Vertex
    <td>Coordinates
  </tr>
</table>

<p>In vertex mode, pressing [<kbd>shift</kbd>][<kbd>Ins</kbd>]
is the same as pressing [<kbd>Ins</kbd>] except that the path is
closed (an additional linedef is created from the last to the
first vertex).

		<h3>Copying objects</h3>

<p>When you press [<kbd>o</kbd>], the selected or highlighted
object(s) is(are) copied. If only one object has been copied,
the new copy is spawned under the pointer. If several objects
have been copied, the new copies are spawned so that their
centre is under the pointer.

<p>The new copies are spawned selected and everything else is
unselected so that you can easily drag them where you want.

<p>All the properties of the new objects are copied from the
original objects with the notable exception of references. If
you are an OO programmer, think shallow copy vs. deep copy.
Otherwise, read on.

<p>When you copy linedefs, the start and end vertices are copied
too and the new linedefs reference the new vertices instead of
the old ones. The same thing goes for sidedefs, except if the
<code>copy_linedef_reuse_sidedefs</code> flag is true. In that
case, each new linedef uses the same sidedefs as its "model"
did. This is useful when you want to create many similar
structures, E.G. pillars that stand in the same sector. When all
the structures use the same sidedefs, you can change all
structures at once by editing only one of them. Another benefit
of sharing sidedefs is that it makes your wad file somewhat
leaner, since the sidedef, at 30 bytes, is the largest level
object.

<p>However, sharing sidedefs makes impossible to change one
structure independantly of the others. That's where the "unlink
sidedef" function enters. If you select one or more linedefs and
unlink their sidedefs, Yadex makes the necessary duplications so
that none of the sidedefs they use is also used by any other
linedef outside the selection. Thus you can edit your linedefs
freely. The "unlink sidedef" operation is described in detail
<a href="#unlink_sidedefs">there</a>.

<p>Similarly, when you copy sectors, the linedefs, sidedefs and
vertices are duplicated and the new sectors use the copies, not
the original ones. Note that the
<code>copy_linedef_reuse_sidedefs</code> has not effect when
copying sectors; the new linedefs always use new sidedefs, even
if that flag is set.

<p>What about copying things and vertices&nbsp;? Well, those
don't contain references to other objects, so there are no
special precautions to take when duplicating them. Except for
the position, the copy is exactly identical to the original.

		<h3>Deleting objects</h3>

To be written. There is already a concise description in the <a
href="getting_started.html">getting started</a> document.

<br>Basically, use [<kbd>Del</kbd>].

		<h3>Changing the properties of objects</h3>

To be written. There is already a concise description in the <a
href="getting_started.html">getting started</a> document.

<br>Executive summary: use [<kbd>return</kbd>] and double-click.

		<h3>Moving objects a.k.a. drag-and-drop</h3>

To be written. There is already a concise description in the <a
href="getting_started.html">getting started</a> document.

		<h3>Renumbering objects</h3>

Normally, you don't have to worry very much about the actual
numbers of the linedefs, sectors, sidedefs, things and vertices
you manipulate. You just have to be careful to use the correct
numbers in references but that's all. You don't need to
<em>change</em> the number that a given object bears.

<p>However, for certain things, the <em>relative</em> numbers of
objects matter&nbsp;:

<ul>
  <li>if you have several player 1 starts in your level (which
    is how the voodoo doll trick is done), it's the
    highest-numbered one that the player incarnates in at level
    start,

  <li>if there are several teleport exits in the same sector,
    only the lowest-numbered one is used (but I don't know of
    any interesting application of this fact),

  <li>if there are several superimposed linedefs, the
    lowest-numbered one is drawn like it was in front,

  <li>BSP's transparent doors need one of the door tracks to be
    the lowest-numbered linedef,

  <li>certain linedef types apply only to the lowest-numbered of
    the tagged sectors (IIRC),

  <li>raising stairs use the lowest-numbered linedef.
</ul>

<p>So how do you control the ordering of objects&nbsp;?

			<h4>Exchanging objects numbers</h4>

This function works the same way in all modes. If you select
exactly two objects and press [<kbd>ctrl</kbd>]-[<kbd>x</kbd>]
(or use "Edit-&gt;Exchange objects numbers") they exchange their
numbers. That is, if the first object had number <var>n1</var>
and the second object had number <var>n2</var>, the first object
in renumbered to <var>n2</var> and the second one to
<var>n1</var>. No other objects are renumbered.

<p>At the same time the numbers are exchanged, all relevant
references are fixed up. That is, if you exchange the numbers of
two vertices, all the linedefs that referred to them are changed
accordingly. And if you exchange the numbers of two sectors, all
the sidedefs that referred to them are fixed. The thing to
remember is that this function leaves the level functionally
identical to what it was before, except of course for the
possible side effects of the renumbering itself.

<p><small>(If you wanted (for some reason I can't imagine) to
exchange the numbers without fixing the references, you could do
it by replacing <code>true</code> by <code>false</code> in the
call to <code>exchange_objects_numbers()</code>.)</small>

		<h3>Sector miscellaneous operations</h3>

<p>Unless otherwise specified, all the operation below act on
all the objects in the <em>working set</em>. If there is at
least one selected object, the working set is equal to the
selection. If there is no selected object, the working set is
the currently highlighted object (the object under the pointer).
If there is no selection and no highlighted object, the
selection is empty, of course. If there is a selection and an
object outside the selection, the latter is <em>not</em> part of
the working set.</p>

<dl>
  <dt>Find first free tag number
  <dd>Displays the smallest tag number greater than 0 and not
    used by any linedef or sector.

  <dt>Rotate and scale sectors
  <dd>(description to be written)

  <dt>Make door from sector
  <dd>(description to be written)

  <dt>Make lift from sector
  <dd>(description to be written)

  <dt>Distribute sector floor heights
  <dd>(description to be written)

  <dt>Distribute sector ceiling heights
  <dd>(description to be written)

  <dt>Raise or lower sectors...
  <dd>Prompts you for a number (N) and adds that number to the
    floor and ceiling heights of all the sectors in the working
    set. If N is positive, this results in raising the sectors
    by N units. If N is negative, this results in lowering the
    sectors by -N units.

  <dt>Brighten or darken sectors...
  <dd>Prompts you for a number (N) and adds that number to the
    light level of all the sectors in the working set. If N is
    positive, this results in sectors becoming brighter. If N is
    positive, this results in sectors becoming darker. No light
    level is decreased below 0 or increased above 255.

  <dt>Unlink room
  <dd>This function is not implemented yet.

  <dt>Mirror horizontally
  <dd>This function starts by determining the set <var>S</var>
    of vertices that are used by the sectors in the working set.
    Then all the vertices in <var>S</var> have their
    x-coordinate changed so that they're "mirrored" around the
    vertical axis that intersects the geometric centre of
    <var>S</var>. Finally, all the linedefs whose both vertices
    belong to <var>S</var> are flipped so that the sector
    references remain correct.

    <p>This function is designed to be used on either the whole
    level or a group of isolated sectors (like in the
    screenshots below). It is not recommended to use it on a
    group of sectors if that group is connected to other
    sectors. You can do it but the resulting mess might take you
    some time to untangle, especially if there are many
    connecting linedefs.

    <p>A common use for this function is when you have a
    symmetrical room with, say, the same staircase on both sides
    of the axis of symmetry. You can build one staircase, make a
    copy of it, mirror the copy and paste it on the other side
    of the room.

    <p>See the "Mirror horizontally" linedef function.

  <dt>Mirror vertically
  <dd>This function starts by determining the set <var>S</var>
    of vertices that are used by the sectors in the working set.
    Then all the vertices in <var>S</var> have their
    y-coordinate changed so that they're "mirrored" around the
    horizontal axis that intersects the geometric centre of
    <var>S</var>. Finally, all the linedefs whose both vertices
    belong to <var>S</var> are flipped so that the sector
    references remain correct.

    <p>This function is designed to be used on either the whole
    level or a group of isolated sectors (like in the
    screenshots below). It is not recommended to use it on a
    group of sectors if that group is connected to other
    sectors. You can do it but the resulting mess might take you
    some time to untangle, especially if there are many
    connecting linedefs.

    <p>A common use for this function is when you have a
    symmetrical room with, say, the same staircase on both sides
    of the axis of symmetry. You can build one staircase, make a
    copy of it, mirror the copy and paste it on the other side
    of the room.

    <p>See the "Mirror vertically" linedef function.

  <dt>Swap flats
  <dd>For each sector in the working set, exchange the floor
    texture with the ceiling texture.

</dl>

		<h3>Thing miscellaneous operations</h3>

<p>Unless otherwise specified, all the operation below act on
all the objects in the <em>working set</em>. If there is at
least one selected object, the working set is equal to the
selection. If there is no selected object, the working set is
the currently highlighted object (the object under the pointer).
If there is no selection and no highlighted object, the
selection is empty, of course. If there is a selection and an
object outside the selection, the latter is <em>not</em> part of
the working set.</p>

<dl>
  <dt>Find first free tag number
  <dd>Displays the smallest tag number greater than 0 and not
    used by any linedef or sector.

  <dt>Rotate and scale things
  <dd>(description to be written)

  <dt>Spin things 45° clockwise
  <dd>Subtract 45 to the angle of all the things in the working
    set. This is not to be confused with "Rotate and scale
    things" where it's the <em>position</em> of the things that
    is changed.

  <dt>Spin things 45° counter-clockwise
  <dd>Add 45 to the angle of all the things in the working set.
    This is not to be confused with "Rotate and scale things"
    where it's the <em>position</em> of the things that is
    changed.

  <dt>Mirror horizontally
  <dd>All the things in the working set have their x-coordinate
    changed so that they're "mirrored" around the horizontal
    axis that intersects the geometric centre of the things in
    the working set. Their angle is also adjusted.

    <p>It is not possible to mirror things without changing
    their angle (short of commenting out a couple of lines in
    <code>x_mirror.cc</code> and recompiling, of course).

  <dt>Mirror vertically
  <dd>All the things in the working set have their y-coordinate
    changed so that they're "mirrored" around the horizontal
    axis that intersects the geometric centre of the things in
    the working set. Their angle is also adjusted.

    <p>It is not possible to mirror things without changing
    their angle (short of commenting out a couple of lines in
    <code>x_mirror.cc</code> and recompiling, of course).
</dl>

		<h3>Setting/toggling/clearing thing flags</h3>

<p>In things mode, press [<kbd>a</kbd>] to open the "set thing
flags" popup menu. <br>Press [<kbd>b</kbd>] to open the "toggle
thing flags" popup menu. <br>Press [<kbd>c</kbd>] to open the
"clear thing flags" popup menu.

		<h3>Vertex miscellaneous operations</h3>

<p>Unless otherwise specified, all the operation below act on
all the objects in the <em>working set</em>. If there is at
least one selected object, the working set is equal to the
selection. If there is no selected object, the working set is
the currently highlighted object (the object under the pointer).
If there is no selection and no highlighted object, the
selection is empty, of course. If there is a selection and an
object outside the selection, the latter is <em>not</em> part of
the working set.</p>

<dl>
  <dt>Find first free tag number
  <dd>Displays the smallest tag number greater than 0 and not
  used by any linedef or sector.

  <dt>Rotate and scale vertices
  <dd>(description to be written)

  <dt>Delete vertex and join linedefs
  <dd>(description to be written)

  <dt>Merge several vertices into one
  <dd>(description to be written)

  <dt>Add a linedef and split sector
  <dd>To perform this operation, you must have exactly two
    vertices in the working set and there must be an
    uninterrupted path of linedefs that face a common sector
    between them. A new linedef is inserted from the first
    vertex to the second. The newly created sector is put on the
    left side of the new linedef.

  <dt>Mirror horizontally
  <dd>All the vertices in the working set have their
    x-coordinate changed so that they're "mirrored" around the
    vertical axis that intersects the geometric centre of the
    selected vertices.  Then all the linedefs whose both
    vertices belong to the group of selected vertices are
    flipped so that the sector references remain correct.

    <p>See the "Mirror horizontally" linedef function.

  <dt>Mirror vertically
  <dd>All the vertices in the working set have their
    y-coordinate changed so that they're "mirrored" around the
    horizontal axis that intersects the geometric centre of the
    the selected vertices. Then all the linedefs whose both
    vertices belong to the group of selected vertices are
    flipped so that the sector references remain correct.

    <p>See the "Mirror vertically" linedef function.
</dl>

		<h3>Linedef miscellaneous operations</h3>

<p>Unless otherwise specified, all the operation below act on
all the objects in the <em>working set</em>. If there is at
least one selected object, the working set is equal to the
selection. If there is no selected object, the working set is
the currently highlighted object (the object under the pointer).
If there is no selection and no highlighted object, the
selection is empty, of course. If there is a selection and an
object outside the selection, the latter is <em>not</em> part of
the working set.</p>

<dl>
  <dt>Find first free tag number
  <dd>Displays the smallest tag number greater than 0 and not
  used by any linedef or sector.

  <dt>Rotate and scale LD &amp; SD...
  <dd>(description to be written)

  <dt>Split linedefs (add new vertex)
  <dd>Split all linedefs in the working set, by adding a vertex
    in the middle.

    <p>The key [<kbd>x</kbd>] is a shortcut to this function.

  <dt>Split linedefs and sector
  <dd>Split both linedefs in the working set in the middle by
    adding a vertex for each, create a linedef between the two
    new vertices and split the sector with this new linedef.
    There must be exactly 2 linedefs in the working set and they
    must face a common sector.

    <p>The new linedef goes from the first linedef in the
    working set to the second linedef in the working set. The
    new sector is on the second sidedef of the new linedef.

    <p>There is a bug in this function ; if the sector contains
    other sectors, some sidedefs are given the wrong sector
    number.  Jim Flynn has recently fixed this in DETH. Anyone
    to look into it&nbsp;?

    <p>The key [<kbd>w</kbd>] is a shortcut to this function.

  <dt>Delete linedefs and join sector
  <dd>(description to be written)

  <dt>Flip linedefs
  <dd>The start and end vertices of the linedefs in the working
    set are swapped. Their sidedefs are also swapped, so that
    the sector references remain correct.

    <p>If you want to flip linedefs without swapping their
    sidedefs, you have to use "Flip linedefs" then "Swap
    sidedefs" on them.

  <dt>Swap sidedefs
  <dd>Swap the sidedefs of the linedefs in the working set
    <em>without</em> flipping the linedefs. This means that the
    sector references are also swapped. If you don't understand
    what this implies, don't use this function.

  <dt>Align textures (Y offset)
  <dd>This function is buggy.

  <dt>Align textures (X offset)
  <dd>This function is buggy.

  <dt>Remove 2nd sidedef (make single-sided)
  <dd>When two superimposed linedefs are merged, the result is
    often a two-sided linedefs, even though the second sidedef
    faces no sector.  Use this function to fix the mess.

    <p>It sets the I flag, clears the 2 flag, sets the second
      sidedef to -1, clears the upper and lower texture and
      resets the middle texture to the default (as defined in
      the preferences).

  <dt>Make rectangular nook (32x16)
  <dd>This is a single-key function to make a rectangular nook
    in the middle of a linedef. "Nook" means that, seen from the
    first side of the original linedef, the resulting 5 linedefs
    form a concave figure.

    <p>If the linedef is not long enough, the length of the nook
    is one third of the length of the linedef.</p>

    <table align="center">
      <tr>
	<td><img src="nook1.png" alt="Before" WIDTH=127 HEIGHT=159>
	<td><img src="nook2.png" alt="After" WIDTH=127 HEIGHT=159>
      </tr>
      <tr>
	<td align="right"><i>Before</i>
	<td align="right"><i>After</i>
      </tr>
    </table>

  <dt>Make rectangular boss (32x16)
  <dd>Same thing as "Make rectangular nook" but the resulting
    figure is convex.

  <dt>Set length (move 1st vertex)
  <dd>Prompts you for a length and moves the 1st vertex of the
    linedefs in the working set so that they have the length you
    specified.

  <dt>Set length (move 2nd vertex)
  <dd>Same thing as "Set length (move 1st vertex) but moves the
    2nd vertex.

  <dt><a name="unlink_sidedefs">Unlink 1st sidedef</a>
  <dd>This function is used when you have several linedefs
    sharing common sidedefs and you don't want them to share any
    sidedefs anymore so that you can, for instance, change the
    sector reference or texture of one of the linedefs
    independently from the others.

    <p>Here is how it works&nbsp;: all sidedefs that are used on
    the first side of any linedef in the working set and on any
    side of any linedef <em>not</em> in the working set are
    duplicated and the first side of the concerned linedefs in
    the working set is set to use the copy instead of the
    original.

    <p>Gotcha&nbsp;: note that the linedefs in the working set
    are not "unlinked" from each other. They are only "unlinked"
    from any other (i.e. not in the working set) linedefs.
    Thus, if you have <em>n</em> linedefs that you want to
    unlink from each other, you have to unlink every one of them
    separately. This is so that, if you have, say, two square
    pillars (2 x 4 linedefs that all use the same sidedef), you
    can easily unlink one pillar from the other while still
    having its 4 linedefs all use the same sidedef.

  <dt>Unlink 2nd sidedef
  <dd>Same as "Unlink 1st sidedef" but with second sidedef
    instead of first sidedef.

  <dt>Mirror horizontally
  <dd><p>This function starts by determining the set <var>S</var>
    of vertices that are used by any of the linedefs in the
    working set. Then all the vertices in <var>S</var> have
    their x-coordinate changed so that they're "mirrored" around
    the vertical axis that intersects the geometric centre of
    <var>S</var>. Finally, all the linedefs whose both vertices
    belong to <var>S</var> are flipped so that the sector
    references remain correct.</p>

    <table align="center">
      <tr>
	<td><img src="mirror0.png" alt="Before" WIDTH=125 HEIGHT=125>
	<td><img src="mirrorh.png" alt="After" WIDTH=125 HEIGHT=125>
      </tr>
      <tr>
	<td align="right"><i>Before</i>
	<td align="right"><i>After</i>
      </tr>
    </table>

    <p>This function is designed to be used on either the whole
    level or a group of isolated linedefs (like in the
    screenshots below). It is not recommended to use it on a
    group of linedefs if that group is connected to other
    linedefs. You can do it but the resulting mess might take
    you some time to untangle, especially if there are many
    connecting linedefs.

    <p>A common use for this function is when you have a
    symmetrical room with, say, the same staircase on both sides
    of the axis of symmetry. You can build one staircase, make a
    copy of it, mirror the copy and paste it on the other side
    of the room.

  <dt>Mirror vertically
  <dd><p>This function starts by determining the set <var>S</var>
    of vertices that are used by any of the linedefs in the
    working set. Then all the vertices in <var>S</var> have
    their y-coordinate changed so that they're "mirrored" around
    the horizontal axis that intersects the geometric centre of
    <var>S</var>. Finally, all the linedefs whose both vertices
    belong to <var>S</var> are flipped so that the sector
    references remain correct.</p>

    <table align="center">
      <tr>
	<td><img src="mirror0.png" alt="Before" WIDTH=125 HEIGHT=125>
	<td><img src="mirrorv.png" alt="After" WIDTH=125 HEIGHT=125>
      </tr>
      <tr>
	<td align="right"><i>Before</i>
	<td align="right"><i>After</i>
      </tr>
    </table>

    <p>This function is designed to be used on either the whole
    level or a group of isolated linedefs (like in the
    screenshots below). It is not recommended to use it on a
    group of linedefs if that group is connected to other
    linedefs. You can do it but the resulting mess might take
    you some time to untangle, especially if there are many
    connecting linedefs.

    <p>A common use for this function is when you have a
    symmetrical room with, say, the same staircase on both sides
    of the axis of symmetry. You can build one staircase, make a
    copy of it, mirror the copy and paste it on the other side
    of the room.

  <dt>Cut a slice out of a sector
  <dd><p>You must select exactly two linedefs that face the same
    sector S. This function creates a linedef A that goes from
    the first selected linedef to the second and a linedef B
    that goes from the second to the first. A new sector is
    created between those four linedefs, with attributes
    identical to those of S.</p>

    <table align="center">
      <tr>
	<td><img src="slice1.png" alt="Before" WIDTH=150 HEIGHT=150>
	<td><img src="slice2.png" alt="After" WIDTH=150 HEIGHT=150>
      </tr>
      <tr>
	<td align="right"><i>Before</i>
	<td align="right"><i>After</i>
      </tr>
    </table>

    <p>This function is somewhat similar to
    "split-linedefs-and-sector" except that it creates two
    linedefs instead of one and that it works on doughnut-shaped
    sectors. In fact, this function is the only one that can
    split a sector when there is no linedef path between the
    split points (which is the case when splitting a
    doughnut-shaped sector between its inner and outer borders).

    <p>If there is a linedef path between the selected linedefs,
    this function is equivalent to using
    "add-linedefs-and-split-sector" twice, except that you end
    up with two sectors, not three. FIXME - need a figure.

    <p>If the selected linedefs happen to share a vertex, only
    one linedef is created and the new sector is triangular. The
    linedefs must not be the same or superimposed. FIXME - need
    a figure.

    <p>Linedefs A and B are created with all their attributes
    set to zero and their middle textures set to "<tt>-</tt>".
    They're oriented so that their right sidedefs face the new
    sector. Linedef A is the lowest-numbered one.

    <p>The following restrictions apply&nbsp;:

    <ul>
      <li>selected linedefs must not have two sidedefs in the same sector,
      <li>selected linedefs must not share more than one sector,
      <li>there must be no linedef that would be superimposed with A or B.
    </ul>

    <p>These restrictions are stricter than necessary. They may
    be lifted in the future if time and brain power permit.

    <p>Because this function is not aware of the geometry of the
    selected linedefs, but only of the sectors they face, it can
    be used to split sectors in impossible ways. FIXME - need a
    figure.

    <p>This function assumes the space between the selected
    linedefs is empty. If there are any other linedefs there,
    you will have to fix their sector references manually
    afterwards.

    <p>The key [<kbd>ctrl</kbd>]-[<kbd>k</kbd>] is a shortcut to
    this function.
</dl>

		<h3>Setting/toggling/clearing linedef flags</h3>

<p>In linedefs mode, press [<kbd>a</kbd>] to open the "set
linedef flags" popup menu.
<br>Press [<kbd>b</kbd>] to open the "toggle linedef flags" popup menu.
<br>Press [<kbd>c</kbd>] to open the "clear linedef flags" popup menu.

		<h3>Undoing</h3>

<p>As of this release, undoing is not implemented.

		<h3>Cut-and-paste from one level to another</h3>

<p>As of this release, it's not possible.

		<h3>Using the flat/patch/sprite/texture selector</h3>

<p>
  Selecting (or browing through) flats, patches, sprites and textures is done
  with the flat/patch/sprite/texture selector.
</p>

<p align="center">
  <img src="vflat.png" alt="Browsing flats" WIDTH=287 HEIGHT=104>

<p align="center">
  <img src="vsprite.png" alt="Browsing sprites" WIDTH=543 HEIGHT=221>

<p align="center">
  <img src="vtexture.png" alt="Browsing textures" WIDTH=735 HEIGHT=277>

<p>The elements of the window are, from the top left corner,

<dl>
  <dt>The current name
  <dd>
    This field shows the name of the name that would be returned if
    [<kbd>return</kbd>] was pressed.
    The name is greyed out if no such object exists in the list.
  </dd>

  <dt>The dimension display
  <dd>Disabled for flats.

  <dt>The medusa effect indicator
  <dd>
    In the texture selector, the string "Medusa" appears if using the current
    texture on a double-sided linedef would trigger the medusa effect.
    This occurs on the original Doom engine when patches overlap horizontally
    (i.e. at least one column of the texture has more than one patch in it).
    Recent engines might not be subject to this limitation.
    Boom isn't.
  </dd>

  <dt>The name list
  <dd>
    Shows the names to choose from.
    The name at the top of the list is the first name that's greater than or
    equal to the name in the entry box.
  </dd>
</dl>

<p>The key bindings are as follows&nbsp;:

<dl>
  <dt>Editing
  <dd>
    <dl class="compact">
      <dt>[<kbd>backspace</kbd>]
      <dd>Erase the rightmost character.

      <dt>[<kbd>ctrl</kbd>]-[<kbd>u</kbd>]
      <dd>Clear the current name.

      <dt>[<kbd>ctrl</kbd>]-[<kbd>w</kbd>]
      <dd>Clear the current name.

      <dt>[<kbd>tab</kbd>]
      <dd>
	Name completion, as in certain Unix programs.
	The current name is replaced by the name at the top of name list.
	For example, if the current name is "<code>SW1</code>" and you press
	[<kbd>tab</kbd>], the current name is set to the first name that begins
	with "<code>SW1</code>".
      </dd>
    </dl>
  </dd>

  <dt>Moving
  <dd>
    <dl class="compact">
      <dt>[<kbd>ctrl</kbd>]-[<kbd>b</kbd>]
      <dd>Move one page up in the list and update the current name.

      <dt>[<kbd>ctrl</kbd>]-[<kbd>f</kbd>]
      <dd>Move one page down in the list and update the current name.
	
      <dt>[<kbd>ctrl</kbd>]-[<kbd>n</kbd>]
      <dd>
	Move to the next sprite group, i.e. skip to the next name in the list
	whose first four characters are not the same as the current name.
	It's handy to skip the 69 animation frames of the heavy weapon dude at
	once.
      </dd>

      <dt>[<kbd>ctrl</kbd>]-[<kbd>p</kbd>]
      <dd>
	Move to the previous sprite group (see
	[<kbd>ctrl</kbd>]-[<kbd>n</kbd>])
      </dd>

      <dt>[<kbd>ctrl</kbd>]-[<kbd>v</kbd>]
      <dd>Move one page down in the list and update the current name.

      <dt>[<kbd>down</kbd>]
      <dd>Set the current name to the second name from the top of the list.

      <dt>[<kbd>end</kbd>]
      <dd>Set the current name to the last name in the list.

      <dt>[<kbd>home</kbd>]
      <dd>Set the current name to the first name in the list.

      <dt>[<kbd>pgdn</kbd>]
      <dd>Move one page down in the list and update the current name.

      <dt>[<kbd>pgup</kbd>]
      <dd>Move one page up in the list and update the current name.

      <dt>[<kbd>up</kbd>]
      <dd>
	Set the current name to the name in the list before the one currently
	shown at the top.
      </dd>
    </dl>
  </dd>

  <dt>Exiting
  <dd>
    <dl class="compact">
      <dt>[<kbd>esc</kbd>]
      <dd>Exit without validating any name (cancel).

      <dt>[<kbd>return</kbd>]
      <dd>
	Validate the current name and exit.
	Has no effect if the current name is greyed-out (invalid).
      </dd>
    </dl>
  </dd>

  <dt>Miscellaneous
  <dd>
    <dl class="compact">
      <dt>[<kbd>ctrl</kbd>]-[<kbd>a</kbd>]
      <dd>Textures: increment the patch count limit.

      <dt>[<kbd>ctrl</kbd>]-[<kbd>x</kbd>]
      <dd>Textures: decrement the patch count limit.

      <dt>[<kbd>f1</kbd>]
      <dd>
	For debugging.
	Print to stdout the location (file name and offset) of the current
	flat, patch or sprite.
      </dd>

      <dt>[<kbd>shift</kbd>]-[<kbd>f1</kbd>]
      <dd>
	Save the current image to file, in packed PPM (<tt>P6</tt>) format.
	This can be useful for textures, that cannot be directly extracted from
	wads.
	Transparent areas are represented according to the DeuTex convention by
	colour rgb:0/2f/2f (<img src="002f2f.png" alt="Swatch" width="8"
	height="8">).
	The file is created in the working directory and its name is the name
	of the image lowercased and suffixed by "<tt>.ppm</tt>".
	For example, flat "<tt>FLOOR0_7</tt>" would be saved as
	"<tt>./floor0_7.ppm</tt>".
	If the file already exists, it's mercilessly overwritten.

	<p>
	  Note that under MS-DOS, newlines in the PPM header are in Unix format
	  (LF, not CR LF).
	</p>
      </dd>
    </dl>
  </dd>
</dl>

<p>
  Whenever the current name changes, the name list scrolls automatically so
  that the first line of the list shows the first valid name that's greater
  than or equal to the current name.
  If the current name does not belong to the list, it is greyed out and you
  can't validate.
  If it does, the corresponding image is shown in the box to the right.
</p>

<p>There are a few bugs left in this function. Textures are
clipped to the dimension of the selector window. Under MS-DOS,
some "<tt>VILE*</tt>" sprites will not save, because their names
contain characters that are not allowed in file names
("<tt>[</tt>", "<tt>\</tt>" and "<tt>]</tt>").

		<h3>Saving</h3>

<p>There are two ways to save&nbsp;:

<ul>
  <li><p>Press [<kbd>f2</kbd>] or do "File-&gt;Save". If the level
    comes from the iwad or if its level name or file name is
    unknown (because it's a new level), you are prompted for a
    level name (EnMn or MAPnm) and a file name first. If the
    file name has changed since the last time you saved, and if
    a file of that name already exists, you are asked
    confirmation before saving.

    <p>The level in the window is saved in the specified file,
    in the pwad format, under the specified .

  <li><p>Press [<kbd>f3</kbd>] or do "File-&gt;Save as".
    This procedure is identical to the "Save" procedure except
    that the query for a level name and file name is
    unconditional.
</ul>

<p>FIXME -- this needs to be written...

<p>If Yadex is in Hexen mode, saving is disabled because writing
levels in the Hexen format is not supported as of this release.



		<h3>Closing a window</h3>

<p>There are two ways to close a window&nbsp;:

<ul>
  <li><p>Press [<kbd>esc</kbd>]. If you have made changes since the
    last time you saved, or if you have never saved, Yadex
    requires confirmation before closing the window.

  <li><p>Press [<kbd>q</kbd>] or do "File-&gt;Quit". If
    you have made changes since the last time you saved, or if
    you have never saved, Yadex first saves the level, using the
    same procedure as when you press [<kbd>f2</kbd>]. After that
    the window is closed. If the saving procedure is interactive
    (for example because it's the first time you save), and if
    you cancel it, the window is not closed.

</ul>
